/*
 * Copyright (C) 1996-2018 The Squid Software Foundation and contributors
 *
 * Squid software is distributed under GPLv2+ license and includes
 * contributions from numerous individuals and organizations.
 * Please see the COPYING and CONTRIBUTORS files for details.
 */

#include "squid.h"
#include "http/two/HpackHuffmanDecoder.h"

// pre-computed RFC 7541 Huffman lookup tables

struct Huff {
    char C;    ///< character to output
    uint8_t N; ///< number of bits to shift the input pattern
    struct Huff *next; // ptr to sub-table (if any)
};

static Huff hTree[256];

static void
build(struct Huff *tableNode, char c, uint8_t bits, uint8_t pattern)
{
    assert(bits > 0 && bits < 9);
    uint8_t extra = (0xFF >> bits);
    pattern <<= (8-bits);
    do {
        tableNode[pattern+extra].C = c;
        tableNode[pattern+extra].N = bits;
    } while (extra-- > 0);
}

static void
huffmanTreeInit()
{
    static int initialized = 0;
    if (++initialized != 1) {
        --initialized;
        return;
    }

    memset(hTree, 0, sizeof(hTree));

    // Using values from RFC 7541 appendix B.

    struct Huff *T = hTree;
    build(T, '0', 5, 0x0); //   '0' ( 48)  |00000                                         0  [ 5]
    build(T, '1', 5, 0x1); //   '1' ( 49)  |00001                                         1  [ 5]
    build(T, '2', 5, 0x2); //   '2' ( 50)  |00010                                         2  [ 5]
    build(T, 'a', 5, 0x3); //   'a' ( 97)  |00011                                         3  [ 5]
    build(T, 'c', 5, 0x4); //   'c' ( 99)  |00100                                         4  [ 5]
    build(T, 'e', 5, 0x5); //   'e' (101)  |00101                                         5  [ 5]
    build(T, 'i', 5, 0x6); //   'i' (105)  |00110                                         6  [ 5]
    build(T, 'o', 5, 0x7); //   'o' (111)  |00111                                         7  [ 5]
    build(T, 's', 5, 0x8); //   's' (115)  |01000                                         8  [ 5]
    build(T, 't', 5, 0x9); //   't' (116)  |01001                                         9  [ 5]

    build(T, ' ', 6, 0x14); //   ' ' ( 32)  |010100                                       14  [ 6]
    build(T, '%', 6, 0x15); //   '%' ( 37)  |010101                                       15  [ 6]
    build(T, '-', 6, 0x16); //   '-' ( 45)  |010110                                       16  [ 6]
    build(T, '.', 6, 0x17); //   '.' ( 46)  |010111                                       17  [ 6]
    build(T, '/', 6, 0x18); //   '/' ( 47)  |011000                                       18  [ 6]
    build(T, '3', 6, 0x19); //   '3' ( 51)  |011001                                       19  [ 6]
    build(T, '4', 6, 0x1A); //   '4' ( 52)  |011010                                       1a  [ 6]
    build(T, '5', 6, 0x1B); //   '5' ( 53)  |011011                                       1b  [ 6]
    build(T, '6', 6, 0x1C); //   '6' ( 54)  |011100                                       1c  [ 6]
    build(T, '7', 6, 0x1D); //   '7' ( 55)  |011101                                       1d  [ 6]
    build(T, '8', 6, 0x1E); //   '8' ( 56)  |011110                                       1e  [ 6]
    build(T, '9', 6, 0x1F); //   '9' ( 57)  |011111                                       1f  [ 6]
    build(T, '=', 6, 0x20); //   '=' ( 61)  |100000                                       20  [ 6]
    build(T, 'A', 6, 0x21); //   'A' ( 65)  |100001                                       21  [ 6]
    build(T, '_', 6, 0x22); //   '_' ( 95)  |100010                                       22  [ 6]
    build(T, 'b', 6, 0x23); //   'b' ( 98)  |100011                                       23  [ 6]
    build(T, 'd', 6, 0x24); //   'd' (100)  |100100                                       24  [ 6]
    build(T, 'f', 6, 0x25); //   'f' (102)  |100101                                       25  [ 6]
    build(T, 'g', 6, 0x26); //   'g' (103)  |100110                                       26  [ 6]
    build(T, 'h', 6, 0x27); //   'h' (104)  |100111                                       27  [ 6]
    build(T, 'l', 6, 0x28); //   'l' (108)  |101000                                       28  [ 6]
    build(T, 'm', 6, 0x29); //   'm' (109)  |101001                                       29  [ 6]
    build(T, 'n', 6, 0x2A); //   'n' (110)  |101010                                       2a  [ 6]
    build(T, 'p', 6, 0x2B); //   'p' (112)  |101011                                       2b  [ 6]
    build(T, 'r', 6, 0x2C); //   'r' (114)  |101100                                       2c  [ 6]
    build(T, 'u', 6, 0x2D); //   'u' (117)  |101101                                       2d  [ 6]

    build(T, ':', 7, 0x5C); //   ':' ( 58)  |1011100                                      5c  [ 7]
    build(T, 'B', 7, 0x5D); //   'B' ( 66)  |1011101                                      5d  [ 7]
    build(T, 'C', 7, 0x5E); //   'C' ( 67)  |1011110                                      5e  [ 7]
    build(T, 'D', 7, 0x5F); //   'D' ( 68)  |1011111                                      5f  [ 7]
    build(T, 'E', 7, 0x60); //   'E' ( 69)  |1100000                                      60  [ 7]
    build(T, 'F', 7, 0x61); //   'F' ( 70)  |1100001                                      61  [ 7]
    build(T, 'G', 7, 0x62); //   'G' ( 71)  |1100010                                      62  [ 7]
    build(T, 'H', 7, 0x63); //   'H' ( 72)  |1100011                                      63  [ 7]
    build(T, 'I', 7, 0x64); //   'I' ( 73)  |1100100                                      64  [ 7]
    build(T, 'J', 7, 0x65); //   'J' ( 74)  |1100101                                      65  [ 7]
    build(T, 'K', 7, 0x66); //   'K' ( 75)  |1100110                                      66  [ 7]
    build(T, 'L', 7, 0x67); //   'L' ( 76)  |1100111                                      67  [ 7]
    build(T, 'M', 7, 0x68); //   'M' ( 77)  |1101000                                      68  [ 7]
    build(T, 'N', 7, 0x69); //   'N' ( 78)  |1101001                                      69  [ 7]
    build(T, 'O', 7, 0x6A); //   'O' ( 79)  |1101010                                      6a  [ 7]
    build(T, 'P', 7, 0x6B); //   'P' ( 80)  |1101011                                      6b  [ 7]
    build(T, 'Q', 7, 0x6C); //   'Q' ( 81)  |1101100                                      6c  [ 7]
    build(T, 'R', 7, 0x6D); //   'R' ( 82)  |1101101                                      6d  [ 7]
    build(T, 'S', 7, 0x6E); //   'S' ( 83)  |1101110                                      6e  [ 7]
    build(T, 'T', 7, 0x6F); //   'T' ( 84)  |1101111                                      6f  [ 7]
    build(T, 'U', 7, 0x70); //   'U' ( 85)  |1110000                                      70  [ 7]
    build(T, 'V', 7, 0x71); //   'V' ( 86)  |1110001                                      71  [ 7]
    build(T, 'W', 7, 0x72); //   'W' ( 87)  |1110010                                      72  [ 7]
    build(T, 'Y', 7, 0x73); //   'Y' ( 89)  |1110011                                      73  [ 7]
    build(T, 'j', 7, 0x74); //   'j' (106)  |1110100                                      74  [ 7]
    build(T, 'k', 7, 0x75); //   'k' (107)  |1110101                                      75  [ 7]
    build(T, 'q', 7, 0x76); //   'q' (113)  |1110110                                      76  [ 7]
    build(T, 'v', 7, 0x77); //   'v' (118)  |1110111                                      77  [ 7]
    build(T, 'w', 7, 0x78); //   'w' (119)  |1111000                                      78  [ 7]
    build(T, 'x', 7, 0x79); //   'x' (120)  |1111001                                      79  [ 7]
    build(T, 'y', 7, 0x7A); //   'y' (121)  |1111010                                      7a  [ 7]
    build(T, 'z', 7, 0x7B); //   'z' (122)  |1111011                                      7b  [ 7]

    build(T, '&', 8, 0xF8); //   '&' ( 38)  |11111000                                     f8  [ 8]
    build(T, '*', 8, 0xF9); //   '*' ( 42)  |11111001                                     f9  [ 8]
    build(T, ',', 8, 0xFA); //   ',' ( 44)  |11111010                                     fa  [ 8]
    build(T, ';', 8, 0xFB); //   ';' ( 59)  |11111011                                     fb  [ 8]
    build(T, 'X', 8, 0xFC); //   'X' ( 88)  |11111100                                     fc  [ 8]
    build(T, 'Z', 8, 0xFD); //   'Z' ( 90)  |11111101                                     fd  [ 8]

    T = hTree[0xFE].next = new Huff[256]; // 11111110 *
    memset(T, 0, sizeof(*T));

    build(T, '!', 2, 0xF8); //   '!' ( 33)  |11111110|00                                 3f8  [10]
    build(T, '"', 2, 0xF9); //   '"' ( 34)  |11111110|01                                 3f9  [10]
    build(T, '(', 2, 0xFA); //   '(' ( 40)  |11111110|10                                 3fa  [10]
    build(T, ')', 2, 0xFB); //   ')' ( 41)  |11111110|11                                 3fb  [10]

    T = hTree[0xFF].next = new Huff[256]; // 11111111 *
    memset(T, 0, sizeof(*T));

    build(T, '?', 2, 0xFC); //   '?' ( 63)  |11111111|00                                 3fc  [10]

    build(T,  39, 3, 0xFA); //   ''' ( 39)  |11111111|010                                7fa  [11]
    build(T, '+', 3, 0xFB); //   '+' ( 43)  |11111111|011                                7fb  [11]
    build(T, '|', 3, 0xFC); //   '|' (124)  |11111111|100                                7fc  [11]

    build(T, '#', 4, 0xFA); //   '#' ( 35)  |11111111|1010                               ffa  [12]
    build(T, '>', 4, 0xFB); //   '>' ( 62)  |11111111|1011                               ffb  [12]

    build(T,   0, 5, 0xF8); //       (  0)  |11111111|11000                             1ff8  [13]
    build(T, '$', 5, 0xF9); //   '$' ( 36)  |11111111|11001                             1ff9  [13]
    build(T, '@', 5, 0xFA); //   '@' ( 64)  |11111111|11010                             1ffa  [13]
    build(T, '[', 5, 0xFB); //   '[' ( 91)  |11111111|11011                             1ffb  [13]
    build(T, ']', 5, 0xFC); //   ']' ( 93)  |11111111|11100                             1ffc  [13]
    build(T, '~', 5, 0xFD); //   '~' (126)  |11111111|11101                             1ffd  [13]

    build(T, '^', 6, 0xFC); //   '^' ( 94)  |11111111|111100                            3ffc  [14]
    build(T, '}', 6, 0xFD); //   '}' (125)  |11111111|111101                            3ffd  [14]

    build(T, '<', 7, 0xFC); //   '<' ( 60)  |11111111|1111100                           7ffc  [15]
    build(T, '`', 7, 0xFD); //   '`' ( 96)  |11111111|1111101                           7ffd  [15]
    build(T, '{', 7, 0xFE); //   '{' (123)  |11111111|1111110                           7ffe  [15]

    T = hTree[0xFF].next[0xFE].next = new Huff[256]; // 11111111 11111110 *
    memset(T, 0, sizeof(*T));

    build(T,  92, 3, 0xF0); //   '\' ( 92)  |11111111|11111110|000                     7fff0  [19]
    build(T, 195, 3, 0xF1); //       (195)  |11111111|11111110|001                     7fff1  [19]
    build(T, 208, 3, 0xF2); //       (208)  |11111111|11111110|010                     7fff2  [19]

    build(T, 128, 4, 0xE6); //       (128)  |11111111|11111110|0110                    fffe6  [20]
    build(T, 130, 4, 0xE7); //       (130)  |11111111|11111110|0111                    fffe7  [20]
    build(T, 131, 4, 0xE8); //       (131)  |11111111|11111110|1000                    fffe8  [20]
    build(T, 162, 4, 0xE9); //       (162)  |11111111|11111110|1001                    fffe9  [20]
    build(T, 184, 4, 0xEA); //       (184)  |11111111|11111110|1010                    fffea  [20]
    build(T, 194, 4, 0xEB); //       (194)  |11111111|11111110|1011                    fffeb  [20]
    build(T, 224, 4, 0xEC); //       (224)  |11111111|11111110|1100                    fffec  [20]
    build(T, 226, 4, 0xED); //       (226)  |11111111|11111110|1101                    fffed  [20]

    build(T, 153, 5, 0xDC); //       (153)  |11111111|11111110|11100                  1fffdc  [21]
    build(T, 161, 5, 0xDD); //       (161)  |11111111|11111110|11101                  1fffdd  [21]
    build(T, 167, 5, 0xDE); //       (167)  |11111111|11111110|11110                  1fffde  [21]
    build(T, 172, 5, 0xDF); //       (172)  |11111111|11111110|11111                  1fffdf  [21]

    T = hTree[0xFF].next[0xFF].next = new Huff[256]; // 11111111 11111111 *
    memset(T, 0, sizeof(*T));

    build(T, 176, 5, 0xE0); //       (176)  |11111111|11111111|00000                  1fffe0  [21]
    build(T, 177, 5, 0xE1); //       (177)  |11111111|11111111|00001                  1fffe1  [21]
    build(T, 179, 5, 0xE2); //       (179)  |11111111|11111111|00010                  1fffe2  [21]
    build(T, 209, 5, 0xE3); //       (209)  |11111111|11111111|00011                  1fffe3  [21]
    build(T, 216, 5, 0xE4); //       (216)  |11111111|11111111|00100                  1fffe4  [21]
    build(T, 217, 5, 0xE5); //       (217)  |11111111|11111111|00101                  1fffe5  [21]
    build(T, 227, 5, 0xE6); //       (227)  |11111111|11111111|00110                  1fffe6  [21]
    build(T, 229, 5, 0xE7); //       (229)  |11111111|11111111|00111                  1fffe7  [21]
    build(T, 230, 5, 0xE8); //       (230)  |11111111|11111111|01000                  1fffe8  [21]

    build(T, 129, 6, 0xD2); //       (129)  |11111111|11111111|010010                 3fffd2  [22]
    build(T, 132, 6, 0xD3); //       (132)  |11111111|11111111|010011                 3fffd3  [22]
    build(T, 133, 6, 0xD4); //       (133)  |11111111|11111111|010100                 3fffd4  [22]
    build(T, 134, 6, 0xD5); //       (134)  |11111111|11111111|010101                 3fffd5  [22]
    build(T, 136, 6, 0xD6); //       (136)  |11111111|11111111|010110                 3fffd6  [22]
    build(T, 146, 6, 0xD7); //       (146)  |11111111|11111111|010111                 3fffd7  [22]
    build(T, 154, 6, 0xD8); //       (154)  |11111111|11111111|011000                 3fffd8  [22]
    build(T, 156, 6, 0xD9); //       (156)  |11111111|11111111|011001                 3fffd9  [22]
    build(T, 160, 6, 0xDA); //       (160)  |11111111|11111111|011010                 3fffda  [22]
    build(T, 163, 6, 0xDB); //       (163)  |11111111|11111111|011011                 3fffdb  [22]
    build(T, 164, 6, 0xDC); //       (164)  |11111111|11111111|011100                 3fffdc  [22]
    build(T, 169, 6, 0xDD); //       (169)  |11111111|11111111|011101                 3fffdd  [22]
    build(T, 170, 6, 0xDE); //       (170)  |11111111|11111111|011110                 3fffde  [22]
    build(T, 173, 6, 0xDF); //       (173)  |11111111|11111111|011111                 3fffdf  [22]
    build(T, 178, 6, 0xE0); //       (178)  |11111111|11111111|100000                 3fffe0  [22]
    build(T, 181, 6, 0xE1); //       (181)  |11111111|11111111|100001                 3fffe1  [22]
    build(T, 185, 6, 0xE2); //       (185)  |11111111|11111111|100010                 3fffe2  [22]
    build(T, 186, 6, 0xE3); //       (186)  |11111111|11111111|100011                 3fffe3  [22]
    build(T, 187, 6, 0xE4); //       (187)  |11111111|11111111|100100                 3fffe4  [22]
    build(T, 189, 6, 0xE5); //       (189)  |11111111|11111111|100101                 3fffe5  [22]
    build(T, 190, 6, 0xE6); //       (190)  |11111111|11111111|100110                 3fffe6  [22]
    build(T, 196, 6, 0xE7); //       (196)  |11111111|11111111|100111                 3fffe7  [22]
    build(T, 198, 6, 0xE8); //       (198)  |11111111|11111111|101000                 3fffe8  [22]
    build(T, 228, 6, 0xE9); //       (228)  |11111111|11111111|101001                 3fffe9  [22]
    build(T, 232, 6, 0xEA); //       (232)  |11111111|11111111|101010                 3fffea  [22]
    build(T, 233, 6, 0xEB); //       (233)  |11111111|11111111|101011                 3fffeb  [22]

    build(T,   1, 7, 0xD8); //       (  1)  |11111111|11111111|1011000                7fffd8  [23]
    build(T, 135, 7, 0xD9); //       (135)  |11111111|11111111|1011001                7fffd9  [23]
    build(T, 137, 7, 0xDA); //       (137)  |11111111|11111111|1011010                7fffda  [23]
    build(T, 138, 7, 0xDB); //       (138)  |11111111|11111111|1011011                7fffdb  [23]
    build(T, 139, 7, 0xDC); //       (139)  |11111111|11111111|1011100                7fffdc  [23]
    build(T, 140, 7, 0xDD); //       (140)  |11111111|11111111|1011101                7fffdd  [23]
    build(T, 141, 7, 0xDE); //       (141)  |11111111|11111111|1011110                7fffde  [23]
    build(T, 143, 7, 0xDF); //       (143)  |11111111|11111111|1011111                7fffdf  [23]
    build(T, 147, 7, 0xE0); //       (147)  |11111111|11111111|1100000                7fffe0  [23]
    build(T, 149, 7, 0xE1); //       (149)  |11111111|11111111|1100001                7fffe1  [23]
    build(T, 150, 7, 0xE2); //       (150)  |11111111|11111111|1100010                7fffe2  [23]
    build(T, 151, 7, 0xE3); //       (151)  |11111111|11111111|1100011                7fffe3  [23]
    build(T, 152, 7, 0xE4); //       (152)  |11111111|11111111|1100100                7fffe4  [23]
    build(T, 155, 7, 0xE5); //       (155)  |11111111|11111111|1100101                7fffe5  [23]
    build(T, 157, 7, 0xE6); //       (157)  |11111111|11111111|1100110                7fffe6  [23]
    build(T, 158, 7, 0xE7); //       (158)  |11111111|11111111|1100111                7fffe7  [23]
    build(T, 165, 7, 0xE8); //       (165)  |11111111|11111111|1101000                7fffe8  [23]
    build(T, 166, 7, 0xE9); //       (166)  |11111111|11111111|1101001                7fffe9  [23]
    build(T, 168, 7, 0xEA); //       (168)  |11111111|11111111|1101010                7fffea  [23]
    build(T, 174, 7, 0xEB); //       (174)  |11111111|11111111|1101011                7fffeb  [23]
    build(T, 175, 7, 0xEC); //       (175)  |11111111|11111111|1101100                7fffec  [23]
    build(T, 180, 7, 0xED); //       (180)  |11111111|11111111|1101101                7fffed  [23]
    build(T, 182, 7, 0xEE); //       (182)  |11111111|11111111|1101110                7fffee  [23]
    build(T, 183, 7, 0xEF); //       (183)  |11111111|11111111|1101111                7fffef  [23]
    build(T, 188, 7, 0xF0); //       (188)  |11111111|11111111|1110000                7ffff0  [23]
    build(T, 191, 7, 0xF1); //       (191)  |11111111|11111111|1110001                7ffff1  [23]
    build(T, 197, 7, 0xF2); //       (197)  |11111111|11111111|1110010                7ffff2  [23]
    build(T, 231, 7, 0xF3); //       (231)  |11111111|11111111|1110011                7ffff3  [23]
    build(T, 239, 7, 0xF4); //       (239)  |11111111|11111111|1110100                7ffff4  [23]

    build(T,   9, 8, 0xEA); //       (  9)  |11111111|11111111|11101010               ffffea  [24]
    build(T, 142, 8, 0xEB); //       (142)  |11111111|11111111|11101011               ffffeb  [24]
    build(T, 144, 8, 0xEC); //       (144)  |11111111|11111111|11101100               ffffec  [24]
    build(T, 145, 8, 0xED); //       (145)  |11111111|11111111|11101101               ffffed  [24]
    build(T, 148, 8, 0xEE); //       (148)  |11111111|11111111|11101110               ffffee  [24]
    build(T, 159, 8, 0xEF); //       (159)  |11111111|11111111|11101111               ffffef  [24]
    build(T, 171, 8, 0xF0); //       (171)  |11111111|11111111|11110000               fffff0  [24]
    build(T, 206, 8, 0xF1); //       (206)  |11111111|11111111|11110001               fffff1  [24]
    build(T, 215, 8, 0xF2); //       (215)  |11111111|11111111|11110010               fffff2  [24]
    build(T, 225, 8, 0xF3); //       (225)  |11111111|11111111|11110011               fffff3  [24]
    build(T, 236, 8, 0xF4); //       (236)  |11111111|11111111|11110100               fffff4  [24]
    build(T, 237, 8, 0xF5); //       (237)  |11111111|11111111|11110101               fffff5  [24]

    T = hTree[0xFF].next[0xFF].next[0xF6].next = new Huff[256]; // 11111111 11111111 11110110 *
    memset(T, 0, sizeof(*T));

    build(T, 199, 1, 0xEC); //       (199)  |11111111|11111111|11110110|0            1ffffec  [25]
    build(T, 207, 1, 0xED); //       (207)  |11111111|11111111|11110110|1            1ffffed  [25]

    T = hTree[0xFF].next[0xFF].next[0xF7].next = new Huff[256]; // 11111111 11111111 11110111 *
    memset(T, 0, sizeof(*T));

    build(T, 234, 1, 0xEE); //       (234)  |11111111|11111111|11110111|0            1ffffee  [25]
    build(T, 235, 1, 0xEF); //       (235)  |11111111|11111111|11110111|1            1ffffef  [25]

    T = hTree[0xFF].next[0xFF].next[0xF8].next = new Huff[256]; // 11111111 11111111 11111000 *
    memset(T, 0, sizeof(*T));

    build(T, 192, 2, 0xE0); //       (192)  |11111111|11111111|11111000|00           3ffffe0  [26]
    build(T, 193, 2, 0xE1); //       (193)  |11111111|11111111|11111000|01           3ffffe1  [26]
    build(T, 200, 2, 0xE2); //       (200)  |11111111|11111111|11111000|10           3ffffe2  [26]
    build(T, 201, 2, 0xE3); //       (201)  |11111111|11111111|11111000|11           3ffffe3  [26]

    T = hTree[0xFF].next[0xFF].next[0xF9].next = new Huff[256]; // 11111111 11111111 11111001 *
    memset(T, 0, sizeof(*T));

    build(T, 202, 2, 0xE4); //       (202)  |11111111|11111111|11111001|00           3ffffe4  [26]
    build(T, 205, 2, 0xE5); //       (205)  |11111111|11111111|11111001|01           3ffffe5  [26]
    build(T, 210, 2, 0xE6); //       (210)  |11111111|11111111|11111001|10           3ffffe6  [26]
    build(T, 213, 2, 0xE7); //       (213)  |11111111|11111111|11111001|11           3ffffe7  [26]

    T = hTree[0xFF].next[0xFF].next[0xFA].next = new Huff[256]; // 11111111 11111111 11111010 *
    memset(T, 0, sizeof(*T));

    build(T, 218, 2, 0xE8); //       (218)  |11111111|11111111|11111010|00           3ffffe8  [26]
    build(T, 219, 2, 0xE9); //       (219)  |11111111|11111111|11111010|01           3ffffe9  [26]
    build(T, 238, 2, 0xEA); //       (238)  |11111111|11111111|11111010|10           3ffffea  [26]
    build(T, 240, 2, 0xEB); //       (240)  |11111111|11111111|11111010|11           3ffffeb  [26]

    T = hTree[0xFF].next[0xFF].next[0xFB].next = new Huff[256]; // 11111111 11111111 11111011 *
    memset(T, 0, sizeof(*T));

    build(T, 242, 2, 0xEC); //       (242)  |11111111|11111111|11111011|00           3ffffec  [26]
    build(T, 243, 2, 0xED); //       (243)  |11111111|11111111|11111011|01           3ffffed  [26]
    build(T, 255, 2, 0xEE); //       (255)  |11111111|11111111|11111011|10           3ffffee  [26]

    build(T, 203, 3, 0xDE); //       (203)  |11111111|11111111|11111011|110          7ffffde  [27]
    build(T, 204, 3, 0xDF); //       (204)  |11111111|11111111|11111011|111          7ffffdf  [27]

    T = hTree[0xFF].next[0xFF].next[0xFC].next = new Huff[256]; // 11111111 11111111 11111100 *
    memset(T, 0, sizeof(*T));

    build(T, 211, 3, 0xE0); //       (211)  |11111111|11111111|11111100|000          7ffffe0  [27]
    build(T, 212, 3, 0xE1); //       (212)  |11111111|11111111|11111100|001          7ffffe1  [27]
    build(T, 214, 3, 0xE2); //       (214)  |11111111|11111111|11111100|010          7ffffe2  [27]
    build(T, 221, 3, 0xE3); //       (221)  |11111111|11111111|11111100|011          7ffffe3  [27]
    build(T, 222, 3, 0xE4); //       (222)  |11111111|11111111|11111100|100          7ffffe4  [27]
    build(T, 223, 3, 0xE5); //       (223)  |11111111|11111111|11111100|101          7ffffe5  [27]
    build(T, 241, 3, 0xE6); //       (241)  |11111111|11111111|11111100|110          7ffffe6  [27]
    build(T, 244, 3, 0xE7); //       (244)  |11111111|11111111|11111100|111          7ffffe7  [27]

    T = hTree[0xFF].next[0xFF].next[0xFD].next = new Huff[256]; // 11111111 11111111 11111101 *
    memset(T, 0, sizeof(*T));

    build(T, 245, 3, 0xE8); //       (245)  |11111111|11111111|11111101|000          7ffffe8  [27]
    build(T, 246, 3, 0xE9); //       (246)  |11111111|11111111|11111101|001          7ffffe9  [27]
    build(T, 247, 3, 0xEA); //       (247)  |11111111|11111111|11111101|010          7ffffea  [27]
    build(T, 248, 3, 0xEB); //       (248)  |11111111|11111111|11111101|011          7ffffeb  [27]
    build(T, 250, 3, 0xEC); //       (250)  |11111111|11111111|11111101|100          7ffffec  [27]
    build(T, 251, 3, 0xED); //       (251)  |11111111|11111111|11111101|101          7ffffed  [27]
    build(T, 252, 3, 0xEE); //       (252)  |11111111|11111111|11111101|110          7ffffee  [27]
    build(T, 253, 3, 0xEF); //       (253)  |11111111|11111111|11111101|111          7ffffef  [27]

    T = hTree[0xFF].next[0xFF].next[0xFE].next = new Huff[256]; // 11111111 11111111 11111110 *
    memset(T, 0, sizeof(*T));

    build(T, 254, 3, 0xF0); //       (254)  |11111111|11111111|11111110|000          7fffff0  [27]

    build(T,   2, 4, 0xE2); //       (  2)  |11111111|11111111|11111110|0010         fffffe2  [28]
    build(T,   3, 4, 0xE3); //       (  3)  |11111111|11111111|11111110|0011         fffffe3  [28]
    build(T,   4, 4, 0xE4); //       (  4)  |11111111|11111111|11111110|0100         fffffe4  [28]
    build(T,   5, 4, 0xE5); //       (  5)  |11111111|11111111|11111110|0101         fffffe5  [28]
    build(T,   6, 4, 0xE6); //       (  6)  |11111111|11111111|11111110|0110         fffffe6  [28]
    build(T,   7, 4, 0xE7); //       (  7)  |11111111|11111111|11111110|0111         fffffe7  [28]
    build(T,   8, 4, 0xE8); //       (  8)  |11111111|11111111|11111110|1000         fffffe8  [28]
    build(T,  11, 4, 0xE9); //       ( 11)  |11111111|11111111|11111110|1001         fffffe9  [28]
    build(T,  12, 4, 0xEA); //       ( 12)  |11111111|11111111|11111110|1010         fffffea  [28]
    build(T,  14, 4, 0xEB); //       ( 14)  |11111111|11111111|11111110|1011         fffffeb  [28]
    build(T,  15, 4, 0xEC); //       ( 15)  |11111111|11111111|11111110|1100         fffffec  [28]
    build(T,  16, 4, 0xED); //       ( 16)  |11111111|11111111|11111110|1101         fffffed  [28]
    build(T,  17, 4, 0xEE); //       ( 17)  |11111111|11111111|11111110|1110         fffffee  [28]
    build(T,  18, 4, 0xEF); //       ( 18)  |11111111|11111111|11111110|1111         fffffef  [28]

    T = hTree[0xFF].next[0xFF].next[0xFF].next = new Huff[256]; // 11111111 11111111 11111111 *
    memset(T, 0, sizeof(*T));

    build(T,  19, 4, 0xF0); //       ( 19)  |11111111|11111111|11111111|0000         ffffff0  [28]
    build(T,  20, 4, 0xF1); //       ( 20)  |11111111|11111111|11111111|0001         ffffff1  [28]
    build(T,  21, 4, 0xF2); //       ( 21)  |11111111|11111111|11111111|0010         ffffff2  [28]
    build(T,  23, 4, 0xF3); //       ( 23)  |11111111|11111111|11111111|0011         ffffff3  [28]
    build(T,  24, 4, 0xF4); //       ( 24)  |11111111|11111111|11111111|0100         ffffff4  [28]
    build(T,  25, 4, 0xF5); //       ( 25)  |11111111|11111111|11111111|0101         ffffff5  [28]
    build(T,  26, 4, 0xF6); //       ( 26)  |11111111|11111111|11111111|0110         ffffff6  [28]
    build(T,  27, 4, 0xF7); //       ( 27)  |11111111|11111111|11111111|0111         ffffff7  [28]
    build(T,  28, 4, 0xF8); //       ( 28)  |11111111|11111111|11111111|1000         ffffff8  [28]
    build(T,  29, 4, 0xF9); //       ( 29)  |11111111|11111111|11111111|1001         ffffff9  [28]
    build(T,  30, 4, 0xFA); //       ( 30)  |11111111|11111111|11111111|1010         ffffffa  [28]
    build(T,  31, 4, 0xFB); //       ( 31)  |11111111|11111111|11111111|1011         ffffffb  [28]
    build(T, 127, 4, 0xFC); //       (127)  |11111111|11111111|11111111|1100         ffffffc  [28]
    build(T, 220, 4, 0xFD); //       (220)  |11111111|11111111|11111111|1101         ffffffd  [28]
    build(T, 249, 4, 0xFE); //       (249)  |11111111|11111111|11111111|1110         ffffffe  [28]

    build(T,  10, 6, 0xFC); //       ( 10)  |11111111|11111111|11111111|111100      3ffffffc  [30]
    build(T,  13, 6, 0xFD); //       ( 13)  |11111111|11111111|11111111|111101      3ffffffd  [30]
    build(T,  22, 6, 0xFE); //       ( 22)  |11111111|11111111|11111111|111110      3ffffffe  [30]

// XXX: so how does one represent 256 in 8 bits when 0-255 are already taken?
//    build(T, 255, 6, 0xFF); //   EOS (256)  |11111111|11111111|11111111|111111      3fffffff  [30]
}

bool
Http2::HpackHuffmanDecoder::decode(const SBuf &in)
{
    if (in.isEmpty()) // cope with nil input
        return true;

    huffmanTreeInit(); // ensure the decode lookup tree exists

    SBuf pos = in;
    uint8_t A = pos[0];
    uint8_t bitsInA = 8;
    pos.consume(1);

    uint8_t B = 0;
    uint8_t bitsInB = 0;

    struct Huff *T = hTree;
    do {
        // if B is empty
        if (!bitsInB && !pos.isEmpty()) {
            B = pos[0];
            bitsInB = 8;
            pos.consume(1);
        }
        // ensure we have a full octet in A
        if (bitsInA < 8 && bitsInB) {
            A |= (B >> bitsInA); // shuffle what we need from B to A
            if (bitsInB >= 8-bitsInA) {
                // remove what A took from B
                B <<= (8-bitsInA);
                bitsInB -= (8-bitsInA);
                bitsInA = 8;
            } else {
                // B does not have enough bits to fill A
                // shuffle all of them into A, and go back to start of loop
                B = B << (8-bitsInA);
                bitsInA += bitsInB;
                bitsInB = 0;
            }
            if (!bitsInB && !pos.isEmpty())
                continue;
        }

        if (T[A].next) {
            // is a branch node. shift tree nodes and consume all A
            T = T[A].next;
            bitsInA = 0;
            A = 0;
        } else {
            if (!T[A].N) // invalid input
                return false;

            // leaf node. produce output, consume some A, and reset to tree root
            output.append(T[A].C);
            A <<= T[A].N;
            bitsInA -= T[A].N;
            T = hTree;
        }

    } while (bitsInA || bitsInB);

    return true;
}
